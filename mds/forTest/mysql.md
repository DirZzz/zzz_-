# MySQL

* ## 三范式 & 反范式

  * ### 三范式

    * 1/ 确保数据表中每列（字段）的原子性。
    * 2/ 如果一个关系满足第一范式，并且除了主键之外的其他列，都依赖于该主键
    * 3/ 消除冗余，通过外键关联依赖

  * ### 反范式

    * 与第三方式冲突，提倡添加冗余字段，以提高检索效率

---



* ## 数据库事务并发

  * ### 事务隔离级别

    

    * ~~~java
      /* 
      --------------------------------------------------------------------- 
      Isolation level  | Dirty reads | Non-repeatable reads | Phantoms 
      -----------------+-------------+----------------------+-------------- 
      Read Uncommitted |  may occur  | may occur            | may occur 
      -----------------+-------------+----------------------+-------------- 
      Read Committed   |  -          | may occur            | may occur    
      -----------------+-------------+----------------------+-------------- 
      Repeatable Read  |  -          | -                    | may occur 
      -----------------+-------------+----------------------+-------------- 
      Serializable     |  -          | -                    | - 
      --------------------------------------------------------------------- 
      */ 
      ~~~

    * Dirty reads ：脏读

      * 描述：在一次事务中，读取了另一个尚未提交事务正在修改的数据。 

      * 原因：该数据正在被另外的事务修改，数据的最终结果不能确定，就读取了数据。 

      * 强调：争夺已被其它事务占用的某行资源。 

      * 解决：对数据枷锁。
    
        ​		  不要读取正在被其它事务修改的数据
    
    * Non-repeatable reads：不可重复读
    
      *  描述：在一次事务中，某行被读取两次，前后结果不一致的现象。     
      * 原因：在事务第一次读取数据后，有另外的事务更新了数据。 
      * 强调：某行资源被其它事务争夺。 
      * 解决：对数据加锁。事务访问数据时，需要获取数据的锁。 
                第一个事务未提交（释放锁），不允许其它事务访问数据。 
    
    * Phantoms：幻读
    
      * 描述：在一次事务中，对多行集合的查询被执行两次，前后结果不一致的现象。 
      * 原因：在事务第一次查询后，有另外的事务修改了数据（增删改） 
      * 强调：多行资源 
      * 解决：对事务加锁或对整个表加锁。此种情况下，对行加锁已不起作用。 
                第一个事务未提交，不允许其它事务执行。

  ---

  

* ## MySQL 索引

  * ## B+树

---



* ## 数据库锁

---

